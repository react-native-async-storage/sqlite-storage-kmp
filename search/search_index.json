{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Async Storage SQLite","text":"<p>Multiplatform key-value storage backed by SQLite for React Native Async Storage</p> <p>Warning</p> <p>Page in progress</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#010-2024-xx-xx","title":"[0.1.0] - 2024-XX-XX","text":"<p>Initial release.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#sqlitestorage","title":"SQLiteStorage","text":""},{"location":"usage/#creating-an-instance","title":"Creating an instance","text":"kotlinswift <pre><code>import org.asyncstorage.sqlitestorage.SQLiteStorageFactory\n\nval storage = SQLiteStorageFactory(this).create(\"my_database_name\")\n</code></pre> <pre><code>import AsyncStorageSQLite\n\n// The iOS implementation provides a wrapper for SQLiteStorage, \n// abstracting away the need for a factory method call.\nlet storage = AsyncStorageSQLite(\"my_database_name\")\n</code></pre>"},{"location":"usage/#reading","title":"Reading","text":"<p>To read a single entry from the database, use the <code>read</code> method.</p> kotlinswift <pre><code>suspend fun single(): Entry {\n    val entry = storage.read(\"my_key\")\n    return entry\n}\n</code></pre> <pre><code>func single() async throws -&gt; Entry {\n    let entry = try await storage.read(key: \"my_key\")\n    return entry\n}\n</code></pre> <p>To read multiple entries from the database, use the <code>readMany</code> method.</p> kotlinswift <pre><code>suspend fun multi(): List&lt;Entry&gt; {\n    val keys = listOf(\"key1\", \"key2\")\n    val entry = storage.readMany(keys)\n    return entry\n}\n</code></pre> <pre><code>func multi() async throws -&gt; [Entry] {\n    let keys: [String] = [\"key1\", \"key2\"]\n    let entries = try await storage.readMany(keys: keys)\n    return entries\n}\n</code></pre> <p>You can also read entries as a <code>Flow</code>/<code>AsyncSequence</code> using the <code>readAsFlow</code> method. A change in any of provided entries will emit an updated list of entries.</p> kotlinswift <pre><code>suspend fun singleAsFlow() {\n    val keys = listOf(\"key1\", \"key2\", \"key3\")\n    storage.readAsFlow(keys).collect { entries -&gt; \n        updateUi(entries)\n    }\n}\n</code></pre> <pre><code>func singleAsFlow() async throws {\n    let keys: [String] = [\"key1\", \"key2\", \"key3\"]\n    for try await entries in storage.readAsFlow(keys: keys) {\n        updateUi(entries: entries)\n    }\n}\n</code></pre>"},{"location":"usage/#writing","title":"Writing","text":"<p>To write a single entry to the database, use the <code>write</code> method.</p> kotlinswift <pre><code>suspend fun singleWrite() {\n    val entry = Entry(\"my_key\", \"my_value\")\n    storage.write(entry)\n}\n</code></pre> <pre><code>func singleWrite() async throws {\n    let entry = Entry(key: \"my_key\", value: \"my_value\")\n    try await storage.write(entry: entry)\n}\n</code></pre> <p>To write multiple entries to the database, use the writeMany method.</p> kotlinswift <pre><code>suspend fun manyWrite() {\n    val entry1 = Entry(\"key1\", \"\"\"[1, 2, 3]\"\"\")\n    val entry2 = Entry(\"key2\", \"true\")\n    val entry3 = Entry(\"key3\", null)\n    storage.writeMany(listOf(entry1, entry2, entry3))\n}\n</code></pre> <pre><code>func manyWrite() async throws {\n    let entry1 = Entry(key: \"key1\", value: \"[1, 2, 3]\")\n    let entry2 = Entry(key: \"key2\", value: \"true\")\n    let entry3 = Entry(key: \"key3\", value: nil)\n    try await storage.writeMany(entries: [entry1, entry2, entry3])\n}\n</code></pre>"},{"location":"usage/#removing","title":"Removing","text":"<p>To remove a single entry from the database, use the <code>remove</code> method.</p> kotlinswift <pre><code>suspend fun removeSingle() {\n    storage.remove(\"my_key\")\n}\n</code></pre> <pre><code>func removeSingle() async throws {\n    try await storage.remove(key: \"my_key\")\n}\n</code></pre> <p>To remove multiple entries from the database, use the <code>removeMany</code> method.</p> kotlinswift <pre><code>suspend fun removeMany() {\n    val keys = listOf(\"my_key1\", \"my_key2\")\n    storage.removeMany(keys)\n}\n</code></pre> <pre><code>func removeMany() async throws {\n    let keys: [String] = [\"my_key1\", \"my_key2\"]\n    try await storage.removeMany(keys: keys)\n}\n</code></pre>"},{"location":"usage/#merging","title":"Merging","text":"<p>Info</p> <p>Merging rules:</p> <ul> <li>if either value is null, return new value</li> <li>if either value is not Json object or Json array, return new value</li> <li>if both values are valid JSON array, append new one to old one</li> <li>if both values are valid JSON object, merge them deeply following merging rules</li> </ul> <p>To merge a single entry in the database, use the <code>merge</code> method.</p> kotlinswift <pre><code>suspend fun singleMerge() {\n    val entry = Entry(\"key\", \"\"\"{\"name\":\"jerry\",\"friends\":[]}\"\"\")\n    storage.write(entry)\n    val updated = Entry(\"key\", \"\"\"{\"friends\": [\"thomas\"], \"age\": 30}\"\"\")\n    val result = storage.merge(updated) \n    // result: {\"name\": \"jerry\", friends\": [\"thomas\"], \"age\": 30}\n} \n</code></pre> <pre><code>func singleMerge() async throws {\n    let entry = Entry(key: \"key\", value: #\"{\"name\":\"jerry\",\"friends\":[]}\"#)\n    try await storage.write(entry: entry)\n    let updated = Entry(key: \"key\", value: #\"{\"friends\": [\"thomas\"], \"age\": 30}\"#)\n    let result = try await storage.merge(entry: updated)\n    // result: {\"name\": \"jerry\", friends\": [\"thomas\"], \"age\": 30}\n}\n</code></pre> <p>To merge multiple entries in the database, use the <code>mergeMany</code> method.</p> kotlinswift <pre><code>suspend fun manyMerge() {\n    val entry1 = Entry(\"key\", \"\"\"{\"name\":\"henry\",\"friends\":[]}\"\"\")\n    val entry2 = Entry(\"key\", \"\"\"{\"friends\":[\"julia\"]}\"\"\")\n    val entry3 = Entry(\"key\", \"\"\"{\"age\": 40}\"\"\")\n    storage.write(entry1)\n    val result = storage.mergeMany(listOf(entry2, entry3))\n    // result: {\"name\": \"henry\", friends\": [\"julia\"], \"age\": 40}\n}\n</code></pre> <pre><code>func manyMerge() async throws {\n    let entry1 = Entry(key: \"key\", value: #\"{\"name\":\"henry\",\"friends\":[]}\"#)\n    let entry2 = Entry(key: \"key\", value: #\"{\"friends\":[\"julia\"]}\"#)\n    let entry3 = Entry(key: \"key\", value: #\"{\"age\": 40}\"#)\n    try await storage.write(entry: entry1)\n    let result = try await storage.mergeMany(entries: [entry2, entry3])\n    // result: {\"name\": \"henry\", friends\": [\"julia\"], \"age\": 40}\n}\n</code></pre>"},{"location":"usage/#reading-keys","title":"Reading keys","text":"<p>To retrieve all keys used to store entries in the database, use the <code>readKeys</code> method.</p> kotlinswift <pre><code>suspend fun keysSingle(): List&lt;String&gt; {\n    val keys = storage.readKeys()\n    return keys\n}\n</code></pre> <pre><code>func keysSingle() async throws -&gt; [String] {\n    let keys = try await storage.readKeys()\n    return keys\n}\n</code></pre> <p>You can also read keys as a <code>Flow</code>/<code>AsyncSequence</code> using the <code>readKeysAsFlow</code> method. Any change in the entries within the provided key list will trigger an emit of the key list again.</p> kotlinswift <pre><code>suspend fun keysMany() {\n    storage.readKeysAsFlow().collect { keys -&gt;\n        println(\"keys used: $keys\")\n    }\n}\n</code></pre> <pre><code>func keysMany() async throws {\n    for try await keys in storage.readKeysAsFlow() {\n        print(\"keys used: \\(keys)\")\n    }\n}\n</code></pre>"},{"location":"usage/#clearing","title":"Clearing","text":"<p>To clear all entries from the database, use the <code>clear</code> method.</p> <p>Warning</p> <p>This action wipes out whole database.</p> kotlinswift <pre><code>suspend fun clearStorage() {\n    storage.clear()\n}\n</code></pre> <pre><code>func clearStorage() async throws {\n    try await storage.clear()\n}\n</code></pre>"},{"location":"usage/#close-connection","title":"Close connection","text":"<p>To close the connection to the storage, use <code>closeConnection()</code> method. Before closing, the <code>PRAGMA optimize;</code> is executed.</p> <p>Warning</p> <p>Once connection is closed, the storage instance is no longer usable for database reads/writes and will throw an error when done so</p> kotlinswift <pre><code>storage.closeConnection()\n</code></pre> <pre><code>storage.closeConnection()\n</code></pre>"},{"location":"usage/#databasefiles","title":"DatabaseFiles","text":"<p>The <code>DatabaseFiles</code> interface provides methods to access information about database files for given <code>SQLiteStorage</code> instance.</p>"},{"location":"usage/#path-to-a-storage-file","title":"Path to a storage file","text":"<p>Returns an absolute path to the selected database file. Default type is <code>DatabaseFileType.Main</code>.</p> kotlinswift <pre><code>val path = storage.files.path(DatabaseFileType.Index)\n</code></pre> <pre><code>let path = storage.files.path(type: .index)\n</code></pre>"},{"location":"usage/#path-to-containing-directory","title":"Path to containing directory","text":"<p>Returns an absolute path to a directory containing database files.</p> kotlinswift <pre><code>val path = storage.files.dirPath()\n</code></pre> <pre><code>let path = storage.files.dirPath()\n</code></pre>"},{"location":"usage/#delete-database-file","title":"Delete database file","text":"<p>Removes the database file and all related Write-Ahead Logging (WAL) files (<code>-wal</code> and <code>-shm</code>).</p> <p>Warning</p> <p>Make sure the connection to database is closed first!</p> kotlinswift <pre><code>storage.files.delete()\n</code></pre> <pre><code>storage.files.delete()\n</code></pre>"},{"location":"usage/#file-size","title":"File size","text":"<p>Returns the size of a selected database file in bytes. If the file does not exist or cannot be read for some reason, returns <code>null</code>.</p> <p>Info</p> <p>Close the database connection first, to get the most accurate results.</p> kotlinswift <pre><code>val size: Long = storage.files.size(DatabaseFileType.Wal) ?: return\n</code></pre> <pre><code>guard let fileSize = storage.files.size(type: .wal) else {\n    return\n}\nlet size = Int64(truncating: fileSize)\n</code></pre>"},{"location":"usage/#databasefiletype","title":"DatabaseFileType","text":"<p>The <code>DatabaseFileType</code> enum defines the types of database files. Refer to SQLite WAL Format for more information on the WAL file format.</p> <ul> <li><code>Main</code>: The main database file.</li> <li><code>Wal</code>: Write-Ahead Logging (WAL) file.</li> <li><code>Index</code>: Index file.</li> </ul>"}]}